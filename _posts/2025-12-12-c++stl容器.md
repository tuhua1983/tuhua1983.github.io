---
layout:	post
title:	"c++stl容器"
date:	2025-12-12 18:00:00
author:	"向耀湘"
header-img: NULL
tags:
	-c++
	-stl
	-编程
	-容
---

[toc]

# 一、string类

> string类本不是STL的容器，但是它与STL容器有着很多相似的操作。C++中的string类相当于是字符数组，但是其更方便于我们的操作，而且不需要在输入之前初始化字符数组的容量，节省空间。

```c++
#include<string>

/*string 生成*/
string str("123"); //"123"
string str(3,"1"); //"111"
string str = "123"; //"123"

/*string 头尾*/
str.front(); //第一个元素 
str.back(); //最后一个元素 

/*string 迭代器*/
string::iterator iter //一个string的迭代器
str.begin() //指向str第一个元素位置的迭代器 
str.end() //指向str最后一个元素后一个位置的迭代器 

/*string 插入*/
str.push_back('a'); //在尾部插入一个字符
str.insert(s1.begin(), 'a'); //在指定位置前面插入一个字符

/*string 删除*/
str.pop_back(); //删除最后一个元素 
str.erase(str.begin()); //删除迭代器指向元素
str.erase(str.begin()+1, str.end()-2); //删除指定区间的元素
str.erase(1, 6); //删除从索引（1）开始的n（6）个字符

/*string 替换*/
str.replace(str.begin(), str.begin + 5, "boy"); //替换迭代器指定的区间
str.replace(6, 5, "girl"); //替换索引指定的区间，从下标6开始的五个元素 

/*string 拼接*/
str1.append(str2); //str1str2
str1 = str1 + str2; //str1str2

/*string 容量*/
str.size()
str.length()

/*string 遍历*/
for(int i = 0; i < str.size(); i ++ ) //索引遍历 
for(string::iterator iter = str.begin(); iter != str.end(); iter ++ ) //迭代器遍历 
for(auto &x : str) //迭代器另一种便捷方法 

/*string 排序*/
sort(str.begin(), str.end());

/*string 比较*/
str1 < str2 //字典序比较，<、<=、==、>、>=都可以用
str1.compare(str2) //相等为0，str1>str2为1，反之-1

/*sting 查找*/
str.find("123") //从前往后找，若找到，返回首字母下标；反之，返回-1
str.rfind("123") //从后往前找
str.find_first_of("123") //查找第一个属于该字符串的字符返回下标
str.find_first_not_of("123")
str.find_last_of("123")
str.find_last_not_of("123")

/*string 某元素个数*/
str.count('a'); //返回str里a字符的个数 

/*string 分割*/
str.substr(2, 5); //返回从索引2开始的五个元素组成的字符串 

/*string 判空*/
str.empty() //返回布尔值 

/*string 清空*/
str.clear();
```

# 二、vector容器

> vector类似动态扩展的数组，可存储任意类型。支持遍历查找，支持头插尾插。

```c++
#include <vector>

/*vector 定义*/
vector<数据类型> 标识符; //空容器
vector<int> 标识符(n,0); //创建包含n个元素的容器，并初始化为0(可选)
vector<int> vct{1, 2, 3}; //初始化列表
vector<数据类型> 标识符(vec); //将此容器初始化为vec，拷贝构造

/*vector 赋值*/
标识符1 = 标识符2; //等号赋值
标识符.assign(brg,end); //将[brg,end]区间中的数据拷贝赋值
标识符.assign(n,elem); //赋值n个elem

/*vector 插入*/
标识符.push_back(2); //在尾部插入一个2
标识符.insert(迭代器+n, 2); //在指定位置+n插入一个元素

/*vector 访问*/
标识符[n] //和数组一样
标识符.at(n); //与上面类似，越界(如n<0)会返回out_of_range异常
标识符.front(); //返回第一个元素
标识符.back(); //返回最后一个元素

/*vector 删除*/
标识符.pop_back(); //删除最后一个元素
标识符.erase(迭代器); //删除指定元素
标识符.erase(迭代器1, 迭代器2); //删除指定区间内的元素
标识符.clear(); //清空所有元素

/*vector 迭代器*/
vector<类型>::iterator 标识符 //一个vector的迭代器
标识符.begin() //指向标识符第一个元素位置的迭代器
标识符.end() //指向标识符最后一个元素后一个位置的迭代器

/*vector 容量*/
标识符.size() //当前元素个数
标识符.capacity() //当前分配的容量
标识符.empty() //是否为空
标识符.resize(n,vec) //改变大小为n,新元素用vec初始化(不填为0)
标识符.reserve(n) //容器预留n个元素的空间，不初始化

/*vector 遍历*/
for(int i = 0; i < 标识符.size(); i ++ ) //索引遍历 
for(vector<int>::iterator iter = 标识符.begin(); iter != 标识符.end(); iter ++ ) //迭代器遍历 
for(auto &x : vct) //迭代器另一种便捷方法 
    
/*vector 互换*/
标识符1.swap(标识符2); //将标识符2与标识符1互换

/*vector 排序*/
sort(迭代器, 迭代器);

/*vctor 查找*/
标识符.find(标识符2) //从前往后找标识符2，若找到，返回指向该处的迭代器；反之，返回迭代器vct.end()

/*vctor 某元素个数*/
标识符1.count(标识符2); //返回容器里标识符2的个数 
```

# 三、set容器

```c++
#include <set>

/*set 生成*/
set<int> st;

/*set 迭代器*/
set<int>::iterator iter 
st.begin() 
st.end() 

/*set 插入*/
st.insert(2); //插入一个元素

/*set 删除*/
st.erase(st.begin()); //删除迭代器指向元素 
st.erase(2); //删除所有为2的元素 

/*set 容量*/
st.size()

/*set 查找*/
st.find(2) //从前往后找，若找到，返回指向该处的迭代器；反之，返回迭代器st.end()
st.lower_bound(x) //二分查找大于等于x的元素中最小的一个，并返回指向该元素的迭代器。
st.upper_bound(x) //二分查找大于x的元素中最小的一个，并返回指向该元素的迭代器。

/*set 某元素个数*/
st.count(2); //返回容器里2的个数

/*set 判空*/
st.empty() //返回布尔值 

/*set 清空*/
st.clear();

```

# 四、queue容器

```c++
#include <queue>

/*queue 生成*/
queue<int> q;

/*queue 头尾*/
q.front();
q.back();

/*queue 插入*/
q.push(2); //在队尾插入一个元素 

/*queue 删除*/
q.pop(); //在队首删除一个元素

/*queue 容量*/
q.size();

/*queue 判空*/
q.empty()
```

# 五、priority_queue 容器

```c++
#include <queue>

/*priority_queue 生成*/
priority_queue<int> q; //大根堆
priority_queue<int, vector<int>, greater<int>> q; //小根堆

/*priority_queue 插入*/
q.push(2); //把一个元素插入堆 

/*priority_queue 删除*/
q.pop(); //删除堆顶的元素 

/*priority_queue 堆顶*/
q.top(); //返回堆顶元素 

/*priority_queue 容量*/
q.size();

/*priority_queue 判空*/
q.empty()
```

# 六、stack 容器

```c++
#include <stack>

/*stack 生成*/
stack<int> sk;

/*stack 插入*/
sk.push(2); //把一个元素放入栈 

/*stack 删除*/
sk.pop(); //删除栈顶的元素 

/*stack 栈顶*/
sk.top(); //返回栈顶元素 

/*stack 容量*/
sk.size();

/*stack 判空*/
sk.empty()
```

# 七、dequeue 容器

```c++
#include <deque>

/*dequeue 生成*/
dequeue<int> dq;

/*dequeue 头尾*/
dq.front();
dq.back();

/*dequeue 迭代器*/
dq.begin() 
dq.end()

/*dequeue 插入*/
dq.push_front(2); //头插入 
dq.push_back(2); //尾插入 

/*dequeue 删除*/
dq.pop_front(); //头删除 
dq.pop_back(); //尾删除 

/*dequeue 容量*/
dq.size();

/*dequeue 判空*/
dq.empty()

/*dequeue 清空*/
dq.clear();
```

# 八、map 容器

```c++
#include <map>

/*map 生成*/
map<key_type, value_type> name;
map<int, int> mp;

/*map 迭代器*/
map<int, int>::iterator iter
mp.begin() 
mp.end() 

/*map 键值*/
iter->first //key
iter->second //value

/*map 插入*/
mp[2] = 5; //直接添加
mp.insert(pair<int, int>(2, 5)); //insert一个pair

/*删除*/
mp.erase(iter); //删除迭代器所指的键值对 

/*map 容量*/
mp.size()

/*map 查找*/
mp.find(2) //从前往后找，若找到，返回指向该处的迭代器；反之，返回迭代器mp.end()

/*map 某元素个数*/
st.count(2); //返回key为2的个数（map中只可能是0或者1） 

/*map 判空*/
mp.empty() //返回布尔值 

/*map 清空*/
mp.clear();
```

# 九、pair 容器

```c++
#include <utility>

/*pair 生成*/
pair<int, int> pr = make_pair(0,1);
pair<int, int> pr(0, 1);

/*pair 两个值*/
pr.first 
pr.second 

/*pair 多与其他容器结合使用*/
set<pair<int, int>> st;
vector<pair<int, int>> vct(mp.begin(), mp.end());
```

# 十、bitset 容器

```c++
#include<bitset>

/*bitset 生成*/
bitset<4> bt; //生成4位二进制数，初始化为0000
bitset<8> bt(12); //生成8位二进制数，且将10进制数12转化为2进制数存入其中
bitset<8> bt(str); //str可以是只有01的字符串或者字符数组

/*bitset 位运算相关*/
bt1 |= bt2; //两个二进制数取或操作 
bt1 &= bt2; //两个二进制数取与操作 
bt1 ^= bt2; //取异或
bt1 = ~bt1; //取反
bt1 <<= x; //左移右移 
 
bt.test(x) //判断第x个位置是0还是1，也就是输出第x个位置，注意逆序

bt.flip(); //将二进制每一位取反
bt.flip(x); //将二进制第x位取反
bt.set(); //将二进制每一位置为1 
bt.set(x); //将第x个位置置为1
bt.reset(); //将二进制每一位置为0
bt.reset(x); //将第x个位置置为0

/*bitset 容量*/
bt.size() //二进制数组的长度，就是定义的长度；

/*bitset 某元素个数*/
bt.count(); //查询二进制数组中，1的个数

/*bitset 转化字符串*/
string str = bt.to_string(); //将二进制数组转化为字符串。 
```

